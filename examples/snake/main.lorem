apere 'std.lorem'
apere 'raylib.lorem'

numerus cellSize = XX
numerus gridSize = XX
numerus fpsCounter = O
numerus fps = LX 
numerus snakeSpeed = X 
vector inputDir = [O, O] 
numerus snakeLength = I 
vector applePos = [O, O]
asertio isAlive = veri
litera[VI] title = ['S', 'n', 'a', 'k', 'e', '\0']
// vector[C] snakeBody // NOTE: array of structs doesn't work?
numerus[CC] snakeBody
∑(numerus i = O, i < CC, i++):
    snakeBody[i] = O
;

nihil drawSnake = λ():
    ∑(numerus i = O, i < snakeLength, i++):
        si(i ⇔ O):
            drawRectangle(snakeBody[i×II] × cellSize, snakeBody[i×II+I] × cellSize, cellSize, cellSize, green[r], green[g], green[b], green[a])
        ;
        ni:
            drawRectangle(snakeBody[i×II] × cellSize, snakeBody[i×II+I] × cellSize, cellSize, cellSize, darkGreen[r], darkGreen[g], darkGreen[b], darkGreen[a])
        ;
    ;
;

nihil moveSnake = λ():
    ∑(numerus i = (snakeLength - I), i > O, i--):
        snakeBody[i×II] = snakeBody[(i-I)×II]
        snakeBody[i×II+I] = snakeBody[(i-I)×II+I]
    ;

    snakeBody[O] = snakeBody[O] + inputDir[x] // NOTE: no += on array access
    snakeBody[I] = snakeBody[I] + inputDir[y]

    snakeBody[O] = modulo(snakeBody[O], gridSize)
    snakeBody[I] = modulo(snakeBody[I], gridSize)

    si(snakeLength > I):
        // NOTE: there is some problems with redefinition of variable in loops
        ∑(numerus j = I, j < snakeLength, j++):
            si((snakeBody[O] ⇔ snakeBody[j×II]) ∧ (snakeBody[I] ⇔ snakeBody[j×II+I])):
                litera[VIII] scorePrefix = ['S', 'c', 'o', 'r', 'e', ':', ' ', '\0']
                printf(scorePrefix)
                litera[X] scoreStr = toString(snakeLength)
                printf(scoreStr)
                litera[II] newLine = ['\n', '\0']
                printf(newLine)
                isAlive = falso
                finio
            ;
        ;
    ;
;

nihil checkInput = λ():
    si(isKeyDown(key_W)):
        // NOTE: No new initialization for declared structs
        inputDir[x] = O
        inputDir[y] = -I
    ; 
    nisi(isKeyDown(key_A)):
        inputDir[x] = -I
        inputDir[y] = O
    ; 
    nisi(isKeyDown(key_S)):
        inputDir[x] = O
        inputDir[y] = I 
    ; 
    nisi(isKeyDown(key_D)):
        inputDir[x] = I
        inputDir[y] = O 
    ;
;

nihil spawnApple = λ():
    applePos[x] = rand() % gridSize
    applePos[y] = rand() % gridSize
;

nihil spawnSnake = λ():
    snakeBody[O] = rand() % gridSize
    snakeBody[I] = rand() % gridSize
;

nihil drawApple = λ():
    drawRectangle(applePos[x] × cellSize, applePos[y] × cellSize, cellSize, cellSize, red[r], red[g], red[b], red[a])
;

nihil gameLoop = λ():
    initWindow(cellSize × gridSize, cellSize × gridSize, title) 
    setTargetFPS(fps)
    srand(time(O))
    spawnApple()
    spawnSnake()
    ∑(¬windowShouldClose() ∧ isAlive):
        checkInput()
        fpsCounter++ 
        si((fpsCounter % (fps ÷ snakeSpeed)) ⇔ O):
            si((snakeBody[O] ⇔ applePos[x]) ∧ (snakeBody[I] ⇔ applePos[y])):
                snakeLength++
                spawnApple()
            ;
            moveSnake()
        ;
        clearBackground(black[r], black[g], black[b], black[a])
        beginDrawing()
        drawApple()
        drawSnake()
        endDrawing()
    ;
    closeWindow()
;

gameLoop()